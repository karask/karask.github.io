---
layout: post
section-type: post
title: Bitcoin Public Keys
category: Bitcoin
tags: [ 'bitcoin', 'tutorial', 'python', 'keys' ]
---

This part of the tutorial will explore Bitcoin's public keys. We will not attempt to go into the math behind the cryptography involved but provide the necessary resources for people who want to delve deeper. The tutorial is aimed to people who already have some knowledge of how Bitcoin works at a high-level and want to understand how it works at a low-level.

In [ECDSA](https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc){:target="_blank"} a public key is generated from the private key. Elliptic curves operate over [finite fields](https://en.wikipedia.org/wiki/Finite_field){:target="_blank"} and thus all points on the curve are limited to integer coordinates[^1]. The specific curve that Bitcoin uses ([secp256k1](https://en.bitcoin.it/wiki/Secp256k1){:target="_blank"}) is &nbsp;**y<sup>2</sup> = x<sup>3</sup> + 7**&nbsp;. Then the public key **P** is generated by multiplying,  using elliptic curve multiplication, the private key **k** with a special constant **G** called the generator point[^2]: `P = k * G`. Elliptic curve multiplication of an integer with a point results in another point in the curve, which is the public key.

![Elliptic Curve](/assets/images/ecurve.png)

The public key is a point **P** in the elliptic curve. P = (x,y), where both x and y are 32-byte integers. Thus a public key can be expressed with 64 bytes. In Bitcoin, we encode a public key by a prefix that specifies some extra information.

> Remember that we can represent a public key in two forms, compressed and uncompressed. This is where we can reduce the size of the blockchain by using the compressed form.

An encoded uncompressed public key is 65 bytes long since it has the two points (32 bytes each) concatenated and a prefix of 0x04 to specify an uncompressed public key.

Since the curve is mirrored in the x axis the y coordinate can only take 2 values (positive/negative) for a specific x. Thus, an encoded compressed public key is only 33 bytes long and has only the x coordinate with a prefix of 0x02 (when y is positive/even) or 0x03 (when y is negative/odd). 

As an example let us use the following hexadecimal number:

`0dde70823a4bb0ca3bd75a2010e8d5dc091185e73d8b4257a981c695a3eba95b`. 

Let's use [python-bitcoin-utils](https://github.com/karask/python-bitcoin-utils){:target="_blank"} library[^3] to construct a private key object from a WIF and use that to create a public key object to show its two forms.

<pre><code data-trim class="python">
{% raw %}
>>> from bitcoinutils.setup import setup
>>> from bitcoinutils.keys import PrivateKey, PublicKey
>>> setup('testnet')
'testnet'
>>> priv = PrivateKey.from_wif('91h2ReUJRwJhTNd828zhc8RRVMU4krX9q3LNi4nVfiVwkMPfA9p')
>>> pub = priv.get_public_key()
>>> pub.to_hex()                # default is compressed form
'02c1acdac799fb0308b4b6475ddf7967676759d31484ab55555482472f3bc7c3e7'
>>> pub.to_hex(compressed=False)
'04c1acdac799fb0308b4b6475ddf7967676759d31484ab55555482472f3bc7c3e7addc4cbba6656a4be4bc6933a6af712b897a543a09c4b899e5f7b943d38108a8'
{% endraw %}
</code></pre>
<br/> 

To create the PublicKey from the PrivateKey object we make use[^4] of the python ecdsa library as can be seen in [get\_public\_key()](https://github.com/karask/python-bitcoin-utils/blob/fb0849f81117943563b17f1870a9607d48ca9653/bitcoinutils/keys.py#L351-L355){:target="_blank"} on github. The PublicKey object holds the x and y coordinates and can convert accordingly. It checks if y is even or odd and prefixes it with 0x02 and 0x03 respectively. You can check the code of [to\_hex()](https://github.com/karask/python-bitcoin-utils/blob/fb0849f81117943563b17f1870a9607d48ca9653/bitcoinutils/keys.py#L453-L469){:target="_blank"} on github.

Another tool that you can use from the command line is [BX](https://github.com/libbitcoin/libbitcoin-explorer/wiki/Download-BX){:target="_blank"}. It has extensive capabilities including creating WIFs.

<pre><code data-trim class="python">
{% raw %}
$ ./bx wif-to-public 91h2ReUJRwJhTNd828zhc8RRVMU4krX9q3LNi4nVfiVwkMPfA9p
04c1acdac799fb0308b4b6475ddf7967676759d31484ab55555482472f3bc7c3e7addc4cbba6656a4be4bc6933a6af712b897a543a09c4b899e5f7b943d38108a8

$ ./bx wif-to-public cN3fHnPVw4h7ZQSRz2HgE3ko69LTaZa5y3JWpFhoXtAke4MiqVQo
02c1acdac799fb0308b4b6475ddf7967676759d31484ab55555482472f3bc7c3e7
{% endraw %}
</code></pre>



<br/>
Footnotes:

[^1]: A finite field is typically accomplished by applying *modulo p*, where p is a prime number.
[^2]: This is a special point in the elliptic curve that is pre-defined in secp256k1.
[^3]: I use this library in several of the University courses and seminars that I teach. It aims to be low-level but with a lot of comments to help students study the more intricate details. In contrast, other low-level libraries don't elaborate enough in the comments and others are higher-level libraries abstracting away a lot of the details that we are trying to decompose and understand in the lessons.
[^4]: It is always recommended to reuse well-tested cryptography libraries than implementing your own.
